---
alwaysApply: true
---

# INSTRUKCJE AGENTA - AI TEXT ASSISTANT PROJECT

## ZASADY PODSTAWOWE (NadpisujƒÖ wszystkie inne)

**NIGDY NIE R√ìB PUSH NA GIT!** - To jest najwa≈ºniejsza zasada.

### Proces pracy
1. **Analiza przed dzia≈Çaniem** - zawsze przeanalizuj strukturƒô projektu
2. **Zachowanie formatowania** - nie zmieniaj istniejƒÖcego formatowania
3. **Konsultacja przed implementacjƒÖ** - podaj opcje, czekaj na wyb√≥r
4. **Git tylko na pro≈õbƒô** - ≈ºadnych automatycznych commit√≥w/push√≥w

---

## ZASADY PROJEKTOWE SPECYFICZNE

### 1. ARCHITEKTURA I PERFORMANCE
**Performance jest najwa≈ºniejszy** - ka≈ºda decyzja musi byƒá oceniona pod kƒÖtem latency:
- STT processing: <200ms target
- AI API calls: <300ms first token  
- UI responsiveness: <100ms
- Memory usage: <30MB idle, <100MB peak

**Zawsze implementuj**:
```rust
// Performance measurement w ka≈ºdej krytycznej funkcji
let start = std::time::Instant::now();
// ... operations ...
let duration = start.elapsed();
tracing::debug!("Operation took: {:?}", duration);
```

### 2. ERROR HANDLING PATTERNS
U≈ºywaj consistent error handling:

**Rust side:**
```rust
// Zawsze u≈ºywaj custom error types
#[derive(Debug, thiserror::Error)]
pub enum AudioError {
    #[error("No input device available")]
    NoInputDevice,
    #[error("Processing timeout: {0}ms")]
    ProcessingTimeout(u64),
}

// Result types dla wszystkich fallible operations
pub type AudioResult<T> = Result<T, AudioError>;
```

**TypeScript side:**
```typescript
// Consistent error handling pattern
try {
  const result = await invoke('audio_command', params);
  return { success: true, data: result };
} catch (error) {
  console.error('Audio command failed:', error);
  return { success: false, error: error.toString() };
}
```

### 3. STRUKTURA PROJEKTU - GDZIE CO UMIESZCZAƒÜ

**Rust Backend (src-tauri/src/):**
- `commands/` - Tauri commands (frontend-backend bridge)
- `core/` - Business logic (coordinators, workflows)
- `audio/` - Audio processing (capture, VAD, buffers)
- `stt/` - Speech-to-text engines
- `ai/` - AI processing and providers
- `system/` - OS integration (hotkeys, clipboard)
- `utils/` - Shared utilities

**React Frontend (src/):**
- `components/ui/` - Reusable UI primitives
- `components/audio/` - Audio-specific components
- `components/ai/` - AI processing components
- `hooks/` - Custom React hooks
- `stores/` - Zustand state management
- `services/` - API integrations

### 4. NAMING CONVENTIONS

**Rust:**
- Modules: `snake_case` (audio_capture.rs)
- Structs: `PascalCase` (AudioCapture)
- Functions: `snake_case` (start_capture)
- Constants: `SCREAMING_SNAKE_CASE` (MAX_BUFFER_SIZE)

**TypeScript:**
- Components: `PascalCase` (AudioVisualizer.tsx)
- Hooks: `camelCase` starting with 'use' (useAudioCapture.ts)
- Utilities: `camelCase` (formatDuration)
- Types/Interfaces: `PascalCase` (AudioConfig)

### 5. IMPORT PATTERNS

**Rust imports:**
```rust
// Standard library first
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

// External crates
use tokio::time::Duration;
use serde::{Deserialize, Serialize};

// Local crates (absolute paths)
use crate::audio::types::AudioConfig;
use crate::utils::error::AppError;
```

**TypeScript imports:**
```typescript
// React/external libs first
import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';

// Internal imports (absolute paths with @)
import { useAppStore } from '@/stores/appStore';
import { AudioVisualizer } from '@/components/audio/AudioVisualizer';
import type { AudioConfig } from '@/types/audio';
```

---

## IMPLEMENTACJA GUIDELINES

### 1. AUDIO SYSTEM
**Zawsze u≈ºywaj thread-safe patterns:**
```rust
// Shared state pattern
pub struct AudioCapture {
    buffer: Arc<Mutex<CircularBuffer>>,
    is_recording: Arc<AtomicBool>,
}

// VAD integration w ka≈ºdym audio handler
let is_speech = self.vad.process_frame(audio_data)?;
if is_speech {
    // Process only when speech detected
}
```

### 2. AI INTEGRATION
**Connection pooling jest mandatory:**
```rust
// Zawsze konfiguruj HTTP client z poolingiem
let client = reqwest::Client::builder()
    .pool_max_connections_per_host(100)
    .pool_idle_timeout(Duration::from_secs(90))
    .timeout(Duration::from_secs(30))
    .build()?;
```

**Streaming responses pattern:**
```rust
// Zawsze implement streaming dla AI responses  
pub async fn process_streaming(&self, request: AIRequest) -> impl Stream<Item = String> {
    // Implementation that yields tokens as they arrive
}
```

### 3. SYSTEM INTEGRATION
**Global hotkeys pattern:**
```rust
// Zawsze u≈ºywaj tego pattern dla hotkeys
manager.register(&shortcut, move || {
    // Emit event rather than direct action
    emit_hotkey_event(action_id.clone());
})?;
```

**Text selection error handling:**
```rust
// Zawsze implement fallback mechanisms
match get_selected_text_accessibility().await {
    Ok(text) => Ok(text),
    Err(_) => get_selected_text_clipboard().await, // Fallback
}
```

### 4. REACT PATTERNS

**State management z Zustand:**
```typescript
// Zawsze u≈ºywaj tego pattern
interface AudioStore {
  // State
  isRecording: boolean;
  audioLevel: number;
  
  // Actions
  startRecording: () => void;
  updateAudioLevel: (level: number) => void;
}

export const useAudioStore = create<AudioStore>((set) => ({
  isRecording: false,
  audioLevel: 0,
  startRecording: () => set({ isRecording: true }),
  updateAudioLevel: (level) => set({ audioLevel: level }),
}));
```

**Performance optimization:**
```typescript
// Zawsze u≈ºywaj React.memo dla expensive components
export const AudioVisualizer = React.memo(({ level }: { level: number }) => {
  // Memoized component implementation
});

// useCallback dla event handlers
const handleAudioLevel = useCallback((level: number) => {
  updateAudioLevel(level);
}, [updateAudioLevel]);
```

---

## TESTING REQUIREMENTS

### 1. PERFORMANCE TESTS
**Ka≈ºda krytyczna funkcja musi mieƒá benchmark:**
```rust
#[cfg(test)]
mod benchmarks {
    use super::*;
    use std::time::Instant;

    #[tokio::test]
    async fn test_stt_latency() {
        let engine = STTEngine::new().unwrap();
        let audio_data = load_test_audio();
        
        let start = Instant::now();
        let result = engine.transcribe(audio_data).await.unwrap();
        let duration = start.elapsed();
        
        assert!(duration.as_millis() < 200, "STT took {}ms, expected <200ms", duration.as_millis());
    }
}
```

### 2. INTEGRATION TESTS
```rust
// Test end-to-end workflows
#[tokio::test]
async fn test_dictation_workflow() {
    let coordinator = AppCoordinator::new().await.unwrap();
    
    // Test complete flow: audio -> STT -> AI -> clipboard
    let result = coordinator.handle_dictation_workflow().await.unwrap();
    
    assert!(!result.is_empty());
    assert!(result.len() > 10); // Reasonable transcription length
}
```

---

## PRZED KA≈ªDƒÑ IMPLEMENTACJƒÑ

### Checklist do wykonania:
1. **Sprawd≈∫ PRD** - czy implementacja jest zgodna z wymaganiami
2. **Oce≈Ñ performance impact** - czy wp≈Çywa na latency targets
3. **Sprawd≈∫ error handling** - czy wszystkie failure modes sƒÖ pokryte  
4. **Verify memory usage** - czy nie ma potencjalnych leaks
5. **Cross-platform compatibility** - czy dzia≈Ça na macOS i Windows

### Pytania do zadania u≈ºytkownikowi:
- "Czy implementowaƒá [feature] z [option A] czy [option B]?"
- "Czy priorytet performance czy feature completeness?"
- "Czy potrzebny fallback dla [scenario]?"

---

## CODE REVIEW CRITERIA

**Przed zaproponowaniem kodu sprawd≈∫:**
- ‚úÖ Performance targets sƒÖ zachowane
- ‚úÖ Error handling jest comprehensive  
- ‚úÖ Memory management jest safe
- ‚úÖ Cross-platform compatibility
- ‚úÖ Consistent z architectural patterns
- ‚úÖ Tests pokrywajƒÖ critical paths

**Oznacz w komentarzach:**
- üöÄ Performance optimizations
- ‚ö†Ô∏è  Potential bottlenecks
- üîí Security considerations
- üß™ Areas needing testing